<!DOCTYPE HTML>
<html lang="en">
	<head>
		<title>xg + ammo.js [game level]</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #fff;
				background-color: #000;
				text-size-adjust: none;
				margin: 0px;
				padding: 0px;

				font-family: Monospace;
				font-size: 13px;
			}

			#info {
				position: absolute;
				top: 10px;
				width: 100%;
				color: #ffffff;
				padding: 5px 0px;
				text-align: center;
				z-index: 100;
			}

			#loading { font-weight: bold; background: #fa0; color: #fff; padding: 0.25em 1em; position: absolute; top: 0px; right: 0px; z-index: 200 }

			a {
				color: #0080ff;
				text-decoration: none;
			}

			a:hover {
				color: #ff0080;
			}

			.hotkey {
				color: #fa0;
			}

			#progressbar {
				width: 700px;
				height: 20px;
				background: rgb(0,0,0);
				position: absolute; left: calc(50% - 350px); top: calc(50% - 10px);
				z-index: 1000;
			}

			#progressloaded {
				width: 0px;
				height: 20px;
				background: rgb(255,255,255);
			}

			#physicsFPS { position: absolute; top:10px; left: 5px; color: #aaa; opacity: 0.9;
						  padding:0 0 3px 3px;
						  font-family: Helvetica,Arial,sans-serif; font-size:9px; font-weight:bold; line-height:15px }

			#stats { position: absolute; top:10px; left: 5px }
			#stats #fps { background: transparent !important }
			#stats #fps #fpsText { color: #aaa !important }
			#stats #fps #fpsGraph { display: none }
		</style>
	</head>

	<body>
		<div id="loading">Loading ...</div>

		<div id="info">
			<a href="http://alteredqualia.com/" target="_blank">xg</a> -
			physically-based rendering + physics simulation + Garry's Mod atomic map by <a href="http://steamcommunity.com/sharedfiles/filedetails/?id=105984257">bigwig</a> -
			using <a href="https://github.com/kripken/ammo.js" target="_blank">ammo.js</a> physics,
			boxter by <a href="http://archive3d.net/?a=download&id=fb592f17" target="_blank">david diaz</a>,
			wrangler by <a href="http://archive3d.net/?a=download&id=3690e025" target="_blank">robert maillart</a>,
			zil by <a href="http://archive3d.net/?a=download&id=c10182f4" target="_blank">kama</a>,
			skybox by <a href="http://www.humus.name/index.php?page=Textures" target="_blank">humus</a>
			<br/>
			control car with <span class="hotkey">arrows</span> / <span class="hotkey">WASD</span>, press <span class="hotkey">space</span> for brake,
			select car with <span class="hotkey">1</span>, <span class="hotkey">2</span>, <span class="hotkey">3</span>,
			press <span class="hotkey">B</span>, <span class="hotkey">N</span>, <span class="hotkey">M</span> to reset cars
			<br/>
			press <span class="hotkey">L</span> to change lighting,
			<span class="hotkey">P</span> to toggle depth-of-field effect,
			<span class="hotkey">O</span> to change camera
			<div id="physicsFPS"><span class="number" id="nFPS">0</span> FPS (physics)</div>
		</div>

		<div id="container"></div>

		<div id="progressbar"><div id="progressloaded"></div></div>

		<script src="js/xg.min.rgba.js"></script>

		<script src="js/crunch/crn_decomp.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src="js/libs/tween.min.js"></script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var useTransferables = Detector.supportsTransferables();

			var CONFIG = {

				"thirdperson": {

					"fov"		: 40,
					"margin"	: 100,
					"scale"		: 1

				}

			};

			var controlsType = "thirdperson";
			var config = CONFIG[ controlsType ];

			var SCALE = config[ "scale" ];
			var MARGIN = config[ "margin" ];

			var FOV = config[ "fov" ];

			var BRIGHTNESS = 1.25;

			var WIDTH = window.innerWidth;
			var HEIGHT = window.innerHeight - 2 * MARGIN;

			//

			var FLOOR_SIZE = 1600;
			var FLOOR_HEIGHT = 0.0;

			var LEVEL_SCALE = 0.1;

			//

			var progressBarElement = document.getElementById( 'progressbar' );
			var progressLoadedElement = document.getElementById( 'progressloaded' );

			//

			var loadingElement = document.getElementById( 'loading' );
			var loaded = false;
			var loadCounter = 0;

			var fpsElement = document.getElementById( 'nFPS' );
			var lastFPS = 0;

			var vehicleCounter = 0;
			var numVehicles = 0;

			var vehicleConfigs = {};
			var vehicleConfigsList = [];

			var currentVehicle;

			// controls

			var mouseX = 0;
			var mouseY = 0;

			var targetX = 0.0, targetY = 0.0;
			var angle = 0.0;
			var height = 0.0;
			var target = new XG.Vector3( 0, 1, 0 );

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			var controls, controlsRoot;

			var characterControls = {

				moveForward: false,
				moveBackward: false,
				moveLeft: false,
				moveRight: false

			};

			var vehicleForce = 0.0;
			var vehicleSteering = 0.0;
			var vehicleBrake = 0.0;

			var gyro = new XG.Gyroscope();

			// core

			var renderer, camera, scene, stats, clock;

			// objects

			var vehicles = [];
			var objects = [];

			// lighting configs

			var lightingList = [

				{ position: [ -30.0, 10.0, 30.0 ], color: [ 0.05, 0.3, 1 ],  sunIntensity: 2.0, ambientIntensity: 0.6, skyBrightness: 0.4 },
				{ position: [ -15.0, 15.0, 30.0 ],  color: [ 0.05, 0.2, 1 ], sunIntensity: 2.0, ambientIntensity: 0.95, skyBrightness: 0.95 },
				{ position: [ -9.0, 50.0, 30.0 ],  color: [ 0.05, 0.05, 1 ], sunIntensity: 2.0, ambientIntensity: 1.25, skyBrightness: 1.25 }

			];

			var lightingIndex = 0;

			// camera configs

			var cameraList = [

				{ fov: 40, dofFocusWidth: 100, dofFocusRampWidth: 100 },
				{ fov: 50, dofFocusWidth: 200, dofFocusRampWidth: 200 },
				{ fov: 20, dofFocusWidth: 10, dofFocusRampWidth: 100 }

			];

			var cameraIndex = 0;

			//

			var levelGeometries = [];


			//

			var lightProbesManager;
			var probe;

			var dynamicObjects = [];

			//

			init();
			animate();

			// -----------------------------

			function showPhysicsFPS() {

				var now = Date.now();

				if ( now - lastFPS > 333 ) {

					fpsElement.innerHTML = simulation.currentFPS;
					lastFPS = now;

				}

			}

			// -----------------------------

			function init() {

				var container = document.getElementById( 'container' );

				// renderer

				var parameters = { width: WIDTH, height: HEIGHT, scale: SCALE,
								   tonemapping: XG.FilmicOperator, brightness: BRIGHTNESS,
								   antialias: true,
								   useMultipleRenderTargets: true };

				renderer = new XG.DeferredRenderer( parameters );
				container.appendChild( renderer.domElement );

				renderer.domElement.style.position = "absolute";
				renderer.domElement.style.top = MARGIN + "px";
				renderer.domElement.style.left = "0px";

				renderer.shadowMapEnabled = true;
				renderer.shadowMapUseDepthTextures = true;

				renderer.shadowMapSlopeDepthBias = true;
				renderer.shadowMapSlopeScale = 2;
				renderer.shadowMapSlopeBias = 0;

				renderer.shadowMapCullFace = XG.CullFaceNone;

				renderer.ssaoEnabled = true;


				renderer.dofEnabled = true;
				renderer.dofAutofocus = true;
				renderer.dofFocusMaxBlur = 0.1;
				renderer.dofFocusWidth = 100.0;
				renderer.dofFocusRampWidth = 100.0;

				renderer.dofFancy = true;


				renderer.fogEnabled = true;
				renderer.fogColor.setHSV( 0.56, 0.75, 1 );
				renderer.fogStrength = 0.15;
				renderer.fogStart = 1500.0;

				//renderer.useDepthTexture = true;

				// camera

				camera = new XG.PerspectiveCamera( FOV, WIDTH / HEIGHT, 1, 12000 );
				camera.position.y = 15;

				var fovRad = XG.Math.degToRad( camera.fov );
				renderer.dofLensFocalLength = XG.Math.fovToFocalLength( fovRad, 24 );

				// scene

				scene = new XG.Scene();

				scene.add( camera );

				lightProbesManager = new XG.LightProbesManager( renderer, scene, dynamicObjects );
				lightProbesManager.defaultSpecularSize = 128;
				lightProbesManager.defaultDiffuseSize = 16;

				probe = lightProbesManager.createProbe();
				probe.position.set( 0, 2, -10 );

				//scene.add( probe );

				// stats

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '8px';
				stats.domElement.style.zIndex = 100;
				container.appendChild( stats.domElement );

				// physics

				simulation = new XG.PhysicsSimulation( { "useTransferables": useTransferables, "workerUrl": 'js/ammo/ammo.worker.level.js' } );

				// clock

				clock = new XG.Clock();

				// add lights

				initLights();

				// add objects

				initObjects();

				// events

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );

				window.addEventListener( 'resize', onWindowResize, false );

				document.addEventListener( 'keydown', onKeyDown, false );
				document.addEventListener( 'keyup', onKeyUp, false );

			}

			//

			function checkStatus() {

				if ( !loaded )  {

					loadCounter += 1;

					if ( loadCounter > 7 ) {

						loaded = true;
						loadingElement.style.display = "none";

					}

				}

			}


			function resetPositions( objects, from, to ) {

				var nObjects = objects.length;

				if ( from === undefined ) from = 0;
				if ( to === undefined ) to = nObjects;

				var side = Math.ceil( Math.pow( nObjects, 1/3 ) );

				var gap = 0.5;
				var boxSize = 4.0;

				var i = from;

				for ( var x = 0; x < side; x ++ ) {

					for ( var y = 0; y < side; y ++ ) {

						for ( var z = 0; z < side; z ++ ) {

							if ( i === to ) break;

							var body = objects[ i ];

							var position = body.position;
							var rotation = body.quaternion;

							var sx = ( x - side/2 ) * ( boxSize + 0.2 + Math.random() * gap );
							var sy = y * ( boxSize + 1.0 + Math.random() * gap ) + 5;
							var sz = ( z - side/2 ) * ( boxSize + 0.2 + Math.random() * gap ) - side - 3 - 30;

							position.set( sx, sy, sz );
							rotation.set( 0, 0, 0, 1 );

							i += 1;

						}

					}

				}

			}

			function startPhysics( nObjects, carConfigs ) {

				if ( useTransferables ) {

					console.log( "Physics worker using transferables" );

				} else {

					console.log( "Physics worker using cloning" );

				}

				//

				var shapes = [];
				var constraints = [];
				var vehicles = [];

				// OBJECTS

				var mapCrateDiffuse = XG.ImageUtils.loadCRNTexture( "textures/materials/crateDiffuse.crn", checkStatus );
				var mapCrateBump = XG.ImageUtils.loadCRNTexture( "textures/materials/crateBump.crn", checkStatus );

				mapCrateDiffuse.anisotropy = 4;
				mapCrateBump.anisotropy = 4;

				var crateMaterial = new XG.PhongMaterial( { color: 0xaaaaaa, specular: 0x171717, shininess: 50, map: mapCrateDiffuse, bumpMap: mapCrateBump, bumpScale: 0.15 } );
				crateMaterial.parallax = true;
				crateMaterial.parallaxScale = 0.05;

				var boxSize = 4.0;
				boxGeo = new XG.BoxGeometry( boxSize, boxSize, boxSize );

				//

				var boxShape = {

					"id"	: 0,
					"type" 	: "box",

					"sx"	: boxSize * 0.5,
					"sy"	: boxSize * 0.5,
					"sz"	: boxSize * 0.5

				};

				shapes.push( boxShape );

				// add boxes

				for ( var i = 0; i < nObjects; i ++ ) {

					var mesh = new XG.Mesh( boxGeo, crateMaterial );
					mesh.position.set( 0, -10000, 0 );
					mesh.useQuaternion = true;
					scene.add( mesh );

					mesh.receiveShadow = true;
					mesh.castShadow = true;

					dynamicObjects.push( mesh );

					objects[ i ] = mesh;

					var physicsProperties = {

						"shapeId"	: boxShape.id,
						"mass" 		: 20,
						"linearSleepThreshold"  : 0.2,
						"angularSleepThreshold" : 0.25

					};

					mesh.properties.physics = physicsProperties;

				}

				resetPositions( objects );

				// add vehicles

				for ( var carLabel in carConfigs ) {

					var car = carConfigs[ carLabel ];

					var chassisShape = car[ "chassisShape" ];
					shapes.push( chassisShape );

					var parts = car[ "parts" ];
					var chassis = parts[ 0 ];

					var chassisId = objects.length;
					objects.push( chassis );

					var vehicle = car[ "vehiclePhysicsProperties" ];
					vehicle[ "chassisId" ] = chassisId;
					vehicle[ "speed" ] = 0.0;

					car[ "vehicleId" ] = vehicles.length;
					vehicles.push( vehicle );

				}

				// add level

				var scale = LEVEL_SCALE;

				var totalTriangles = 0;

				for ( var i = 0, il = levelGeometries.length; i < il; i ++ ) {

					var id = shapes.length;

					var info = levelGeometries[ i ];

					var geometry = info[ 0 ];
					var mesh 	 = info[ 1 ];

					var index = geometry.attributes[ "index" ];

					if ( index ) {

						var positions = geometry.attributes[ "position" ].array;
						var indices = geometry.attributes[ "index" ].array;

						var shape = {

							"id"	: id,
							"type" 	: "triangleMesh",

							"indexedTriangles" : true,
							"use32bitIndices" : true,

							"vertices" 	: positions,
							"indices"	: indices,

							"scale" : scale

						};

						var numTriangles = indices.length / 3;

					} else {

						var positions = geometry.attributes[ "position" ].array;

						var shape = {

							"id"	: id,
							"type" 	: "triangleMesh",

							"indexedTriangles" : false,

							"vertices" 	: positions,

							"scale" : scale

						};

						var numTriangles = positions.length / 9;

					}

					totalTriangles += numTriangles;

					//console.log( "meshTriangles", numTriangles );

					shapes.push( shape );

					var physicsProperties = {

						"shapeId"	: shape.id,
						"mass" 		: 0

					};

					mesh.properties.physics = physicsProperties;
					objects.push( mesh );

				}

				console.log( "map triangles", totalTriangles );

				// set up callback

				simulation.callbackInitialized = function () {

					console.log( "callbackInitialized" );

					for ( var carLabel in carConfigs ) {

						var car = carConfigs[ carLabel ];
						var parts = car[ "parts" ];

						for ( var i = 0; i < parts.length; i ++ ) {

							var part = parts[ i ];

							if ( part instanceof XG.Mesh ) {

								part.visible = true;

							} else {

								part.children[ 0 ].visible = true;

							}

						}

					}

					checkStatus();

				}

				// init simulation

				var physicsWorld = {

					"objects"	  : objects,
					"shapes"	  : shapes,
					"constraints" : constraints,
					"vehicles"	  : vehicles,
					"floorEnabled": false,
					"floorSize"	  : FLOOR_SIZE,
					"floorHeight" : FLOOR_HEIGHT

				};

				simulation.startPhysics( physicsWorld );

			}

			// -----------------------------

			function initLights() {

				addDayLight();
				addAmbientLight( probe );

				//

				var lighting = lightingList[ lightingIndex ];
				var position = lighting.position;
				var color = lighting.color;

				dayLight.intensity = lighting.sunIntensity;
				dayLight.ambientIntensity = lighting.ambientIntensity;

				dayLight.position.set( position[ 0 ], position[ 1 ], position[ 2 ] ).multiplyScalar( 10 );
				dayLight.color.setHSV( color[ 0 ], color[ 1 ], color[ 2 ] );

				skyUniforms.skyBrightness.value = lighting.skyBrightness;

			}


			function addAmbientLight( probe ) {

				var cubemapMip = XG.ImageUtils.loadCompressedTextureCube( 'textures/environments/MipCube.dds' );

				ambientLight = new XG.ImageLight( probe.specularCube, probe.diffuseCube, 1.0 );
				scene.add( ambientLight );

				ambientLight.textureMip = cubemapMip;
				ambientLight.position = probe.position;
				ambientLight.local = false;

			}

			function addDayLight() {

				dayLight = new XG.DayLightCube( 0xffffff, 1.25 );

				dayLight.color.setHSV( 0.05, 0.25, 1 );
				dayLight.intensity = 1.75;
				dayLight.ambientIntensity = 1.5;

				dayLight.castShadow = true;
				dayLight.shadowDarkness = 1;
				dayLight.shadowMapWidth = 1024;
				dayLight.shadowMapHeight = 1024;
				//dayLight.shadowMapWidth = 2048;
				//dayLight.shadowMapHeight = 2048;

				var d = 50;

				dayLight.shadowCameraLeft = -d;
				dayLight.shadowCameraRight = d;
				dayLight.shadowCameraTop = d;
				dayLight.shadowCameraBottom = -d;

				dayLight.shadowCameraNear = 5;
				dayLight.shadowCameraFar = 200;

				dayLight.shadowDarkness = 1.0;

				dayLight.shadowCascade = true;
				dayLight.shadowCascadeCount = 5;
				//dayLight.shadowCascadeNearZ = [ 0.000, 0.97, 0.99, 0.995 ];
				//dayLight.shadowCascadeFarZ  = [ 0.97, 0.99, 0.995, 0.998 ];
				dayLight.shadowCascadeNearZ = [ 0.000, 0.975, 0.995, 0.998, 0.9995 ];
				dayLight.shadowCascadeFarZ  = [ 0.975, 0.995, 0.998, 0.9995, 1.0 ];

				dayLight.position.set( -9.0, 15.0, 30.0 ).multiplyScalar( 10 );
				//dayLight.shadowCascadeOffset.set( 0, 20, -20 );
				dayLight.shadowCascadeOffset.set( 0, 1000, 100 );

				dayLight.shadowCameraNear = 1;
				dayLight.shadowCameraFar = 8000;
				//dayLight.shadowCameraFar = 2500;

				//renderer.renderer.shadowMapDebug = true;
				renderer.shadowMapCascade = true;

				//

				var cubemapSpecular = XG.ImageUtils.loadCompressedTextureCube( 'textures/environments/TeideSpecularCube.dds', checkStatus );
				var cubemapDiffuse = XG.ImageUtils.loadCompressedTextureCube( 'textures/environments/TeideDiffuseCube.dds', checkStatus );

				var compressedSkybox = true;

				var path = 'textures/environments/teide/';
				var format = compressedSkybox ? '.crn' : '.jpg';
				var urls = [
						path + 'posx' + format, path + 'negx' + format,
						path + 'posy' + format, path + 'negy' + format,
						path + 'posz' + format, path + 'negz' + format
					];

				if ( compressedSkybox ) {

					var cubemapSpecularHigh = XG.ImageUtils.loadCRNTextureCube( urls, checkStatus );

				} else {

					var cubemapSpecularHigh = XG.ImageUtils.loadTextureCube( urls, checkStatus );

				}

				//var cubemapSpecular = XG.ImageUtils.loadCompressedTextureCube( 'textures/environments/BeamSpecularCube.dds', checkStatus );
				//var cubemapDiffuse = XG.ImageUtils.loadCompressedTextureCube( 'textures/environments/BeamDiffuseCube.dds', checkStatus );

				//var cubemapSpecular = XG.ImageUtils.loadCompressedTextureCube( 'textures/environments/FalloutSpecularCube.dds', checkStatus );
				//var cubemapDiffuse = XG.ImageUtils.loadCompressedTextureCube( 'textures/environments/FalloutDiffuseCube.dds', checkStatus );
				//var cubemapSpecularHigh = XG.ImageUtils.loadCompressedTextureCube( 'textures/environments/FalloutSpecularCube512.dds', checkStatus );

				dayLight.textureSpecular = cubemapSpecular;
				dayLight.textureDiffuse = cubemapDiffuse;
				dayLight.textureMip = cubemapSpecular;

				scene.add( dayLight );

				//

				addSky( cubemapSpecularHigh, dayLight.ambientIntensity );

			}

			function addSky( cubemap, skyBrightness ) {

				var uniforms = {

					"tCube"	 	: { type: "t", value: null },
					"brightness": { type: "f", value: BRIGHTNESS },
					"skyBrightness": { type: "f", value: skyBrightness }

				};

				var vertexShader = [

					"varying vec3 vWorldPosition;",

					"void main() {",

						"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
						"vWorldPosition = worldPosition.xyz;",

						"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
						"gl_Position = projectionMatrix * mvPosition;",

					"}"

				].join("\n");

				var fragmentShader = [

					"uniform samplerCube tCube;",
					"uniform float skyBrightness;",

					"varying vec3 vWorldPosition;",

					XG.ShaderChunk[ "tonemappingFragmentPars" ],

					"void main() {",

						"gl_FragColor = skyBrightness * textureCube( tCube, vec3( vWorldPosition.x, vWorldPosition.y, vWorldPosition.z ) );",
						"gl_FragColor.xyz *= gl_FragColor.xyz;",
						"gl_FragColor.a = 1.0;",

						//XG.ShaderChunk[ "tonemapping_fragment" ],

					"}"

				].join("\n");

				uniforms[ "tCube" ].value = cubemap;

				var skyMaterial = new XG.ShaderMaterial( {

					vertexShader: 	vertexShader,
					fragmentShader: fragmentShader,
					uniforms: 		uniforms,
					side: 			XG.BackSide

				} );

				var skyGeo = new XG.SphereGeometry( 8000, 16, 8, 0, Math.PI * 2, 0, Math.PI * 0.5 );
				//var skyGeo = new XG.SphereGeometry( 4000, 16, 8, 0, Math.PI * 2, 0, Math.PI * 0.5 );

				sky = new XG.Mesh( skyGeo, skyMaterial );
				//sky.position.y = -200;
				sky.renderDepth = 1;
				scene.add( sky );

				skyUniforms = uniforms;

			}

			// -----------------------------

			function physicsGateCallback() {

				vehicleCounter += 1;

				if ( vehicleCounter === numVehicles + 1 ) {

					for ( var id in vehicleConfigs ) {

						var vehicle = vehicleConfigs[ id ];
						vehicleConfigsList.push( vehicle );

					}

					var initVehicleLabel = "wrangler"; // wrangler camaro zil boxter
					currentVehicle = vehicleConfigs[ initVehicleLabel ];

					var chassis = currentVehicle[ "parts" ][ 0 ];
					var scale = currentVehicle[ "scale" ];

					gyro.add( camera );
					gyro.scale.multiplyScalar( 1/4.5 );
					chassis.add( gyro );

					startPhysics( 10, vehicleConfigs );

					checkStatus();

				}

			}

			function addZilPhysics() {

				var zilCallback = function ( vehicleData ) {

					var chassisMaterials = vehicleData.chassisMaterials;
					var wheelMaterials = vehicleData.wheelMaterials;
					var parts = vehicleData.parts;
					var scale = vehicleData.scale;
					var chassisShape = vehicleData.chassisShape;
					var vehiclePhysicsProperties = vehicleData.vehiclePhysicsProperties;

					chassisMaterials[0].specular.setHSV( 0, 0, 0.9 );
					chassisMaterials[0].shininess = 100;

					for ( var i = 0, il = parts.length; i < il; i ++ ) {

						var part = parts[ i ];
						scene.add( part );

						dynamicObjects.push( part );

					}

					vehicleConfigs[ "zil" ] = {

						"parts"			: parts,
						"scale"			: scale,
						"chassisShape"	: chassisShape,
						"vehiclePhysicsProperties" : vehiclePhysicsProperties,
						"maxForce" : 3000.0,
						"maxBrake" : 100.0,
						"maxSpeed" : 100.0

					};

					physicsGateCallback();

				};

				var wheelRadius = 2.6;
				var suspensionRestLength = 1.0;

				var dx = 4.0;
				var dy = -0.55;
				var dzBack = 4.75;
				var dzBack2 = 10.5;
				var dzFront = 10.5;

				var rollInfluence = 0.4;

				var zilConfig = {

				"chassisUrl"	: "models/utf8/zil/zil_body.js",
				"wheelUrl"		: "models/utf8/zil/zil_wheel.js",

				"scale" 		: 4.5,
				"position"		: [ -20, 4, -5 ],
				"chassisOffset"	: [ 0.0, 0.7, 0.0 ],

				"wheels" : [

					{
						"isFrontWheel" 	: true,
						"mirrored" 		: false,

						"wheelRadius" 			: wheelRadius,
						"suspensionRestLength"	: suspensionRestLength,

						"connectionPoint"	: [ -dx, -dy, dzFront ],
						"wheelDirection"	: [ 0, -1, 0 ],
						"wheelAxle"			: [ -1, 0, 0 ]
					},

					{
						"isFrontWheel"	: true,
						"mirrored" 		: true,

						"wheelRadius" 			: wheelRadius,
						"suspensionRestLength"	: suspensionRestLength,

						"connectionPoint"	: [ dx, -dy, dzFront ],
						"wheelDirection"	: [ 0, -1, 0 ],
						"wheelAxle"			: [ -1, 0, 0 ]
					},

					{
						"isFrontWheel"	: false,
						"mirrored" 		: false,

						"wheelRadius" 			: wheelRadius,
						"suspensionRestLength"	: suspensionRestLength,

						"connectionPoint"	: [ -dx, -dy, -dzBack ],
						"wheelDirection"	: [ 0, -1, 0 ],
						"wheelAxle"			: [ -1, 0, 0 ]
					},

					{
						"isFrontWheel"	: false,
						"mirrored"		: false,

						"wheelRadius" 			: wheelRadius,
						"suspensionRestLength"	: suspensionRestLength,

						"connectionPoint"	: [ -dx, -dy, -dzBack2 ],
						"wheelDirection"	: [ 0, -1, 0 ],
						"wheelAxle"			: [ -1, 0, 0 ]
					},

					{
						"isFrontWheel"	: false,
						"mirrored"		: true,

						"wheelRadius" 			: wheelRadius,
						"suspensionRestLength"	: suspensionRestLength,

						"connectionPoint"	: [ dx, -dy, -dzBack ],
						"wheelDirection"	: [ 0, -1, 0 ],
						"wheelAxle"			: [ -1, 0, 0 ]
					},

					{
						"isFrontWheel"	: false,
						"mirrored" 		: true,

						"wheelRadius" 			: wheelRadius,
						"suspensionRestLength"	: suspensionRestLength,

						"connectionPoint"	: [ dx, -dy, -dzBack2 ],
						"wheelDirection"	: [ 0, -1, 0 ],
						"wheelAxle"			: [ -1, 0, 0 ]
					}
				],

				"chassisShape" : {

					"id"	: 2,
					"type"	: "compound",

					"children" : [

						{
							"type" 	: "box",
							"sx"	: 5,
							"sy"	: 1.5,
							"sz"	: 15.75,
							"position" : [ 0.0, 0.5, 0.0 ]

						},

						{
							"type" 	: "box",
							"sx"	: 4.5,
							"sy"	: 1.6,
							"sz"	: 5.9,
							"position" : [ 0.0, 3.7, 8.75 ]

						},

						{
							"type" 	: "box",
							"sx"	: 4.5,
							"sy"	: 1.4,
							"sz"	: 2.9,
							"position" : [ 0.0, 3.5 + 1.6 + 1.4, 5.75 ]

						}

					]

				},

				"chassisPhysicsProperties" : {

					"shapeId"	: 2,
					"mass" 		: 2250.0,
					"linearSleepThreshold"  : 0.2,
					"angularSleepThreshold" : 0.25

				},

				"vehiclePhysicsProperties" : {

					"chassisId" : 2,

					"maxSuspensionTravelCm" : 1000.0,
					"maxSuspensionForce" 	: 20000.0,
					"suspensionStiffness"	: 10.0,
					"rollInfluence"			: rollInfluence

				},

				"debugPhysicsShapes" : false,

				"callback": zilCallback

				};

				simulation.loadPhysicsVehicle( zilConfig );

			}

			function addWranglerPhysics() {

				var wranglerCallback = function ( vehicleData ) {

					var chassisMaterials = vehicleData.chassisMaterials;
					var parts = vehicleData.parts;
					var scale = vehicleData.scale;
					var chassisShape = vehicleData.chassisShape;
					var vehiclePhysicsProperties = vehicleData.vehiclePhysicsProperties;

					for ( var i = 0, il = parts.length; i < il; i ++ ) {

						var part = parts[ i ];
						scene.add( part );

						dynamicObjects.push( part );

					}

					vehicleConfigs[ "wrangler" ] = {

						"parts"			: parts,
						"scale"			: scale,
						"chassisShape"	: chassisShape,
						"vehiclePhysicsProperties" : vehiclePhysicsProperties,
						"maxForce" : 2250.0,
						"maxBrake" : 80.0,
						"maxSpeed" : 150.0

					};

					physicsGateCallback();

				};

				var dx = 3.0;
				var dy = 0.0;
				var dzBack = 5.0;
				var dzFront = 6.0;

				var suspensionRestLength = 0.5;

				var wranglerConfig = {

				"chassisUrl"	: "models/utf8/wrangler/wrangler_body.js",
				"wheelUrl"		: "models/utf8/wrangler/wrangler_wheel.js",

				"scale" 		: 4.2,
				"position"		: [ 0.5, 4.0, 0.5 ],
				"chassisOffset"	: [ 0.0, 0.7, 0.0 ],

				"wheels" : [

					{
						"isFrontWheel"	: true,
						"mirrored" 		: false,

						"wheelRadius" 			: 1.6,
						"suspensionRestLength" 	: suspensionRestLength,

						"connectionPoint"	: [ -dx, -dy, dzFront ],
						"wheelDirection"	: [ 0, -1, 0 ],
						"wheelAxle"			: [ -1, 0, 0 ]
					},

					{
						"isFrontWheel"	: true,
						"mirrored" 		: true,

						"wheelRadius" 			: 1.6,
						"suspensionRestLength" 	: suspensionRestLength,

						"connectionPoint"	: [ dx, -dy, dzFront ],
						"wheelDirection"	: [ 0, -1, 0 ],
						"wheelAxle"			: [ -1, 0, 0 ]
					},

					{
						"isFrontWheel"	: false,
						"mirrored" 		: false,

						"wheelRadius" 			: 1.6,
						"suspensionRestLength" 	: suspensionRestLength,

						"connectionPoint"	: [ -dx, -dy, -dzBack ],
						"wheelDirection"	: [ 0, -1, 0 ],
						"wheelAxle"			: [ -1, 0, 0 ]

					},

					{
						"mirrored"		: true,
						"isFrontWheel"	: false,

						"wheelRadius"			: 1.6,
						"suspensionRestLength" 	: suspensionRestLength,

						"connectionPoint"	: [ dx, -dy, -dzBack ],
						"wheelDirection"	: [ 0, -1, 0 ],
						"wheelAxle"			: [ -1, 0, 0 ]
					}

				],

				"chassisShape" : {

					"id"	: 3,
					"type"	: "compound",

					"children" : [

						{
							"type" 	: "box",
							"sx"	: 3.9,
							"sy"	: 1.9,
							"sz"	: 9.0,
							"position" : [ 0.0, 1.5, 0.0 ]

						},

						{
							"type" 	: "box",
							"sx"	: 3.763,
							"sy"	: 1.5,
							"sz"	: 4.8,
							"position" : [ 0.0, 1.5 + 1.9 + 1.5, -2.8 ]

						}

					]

				},

				"chassisPhysicsProperties" : {

					"shapeId"	: 3,
					"mass" 		: 1050.0,
					"linearSleepThreshold"  : 0.2,
					"angularSleepThreshold" : 0.25

				},

				"vehiclePhysicsProperties" : {

					"chassisId" : 3,

					"maxSuspensionTravelCm" : 750.0,
					"maxSuspensionForce" 	: 6000.0,
					"suspensionStiffness"	: 10.0,
					"suspensionCompression" : 0.83,
					"suspensionDamping"		: 0.88,
					"rollInfluence"			: 0.1

				},

				"debugPhysicsShapes" : false,

				"callback" : wranglerCallback

				};

				simulation.loadPhysicsVehicle( wranglerConfig );

			}

			function addBoxterPhysics() {

				var boxterCallback = function ( vehicleData ) {

					var chassisMaterials = vehicleData.chassisMaterials;
					var wheelMaterials = vehicleData.wheelMaterials;
					var parts = vehicleData.parts;
					var scale = vehicleData.scale;
					var chassisShape = vehicleData.chassisShape;
					var vehiclePhysicsProperties = vehicleData.vehiclePhysicsProperties;

					//chassisMaterials[9].color.setHSV( 0.05, 1, 0 );
					//chassisMaterials[9].color.setHSV( 0.05, 1, 0.8 );
					chassisMaterials[9].specular.setHSV( 0, 0, 0.9 );

					chassisMaterials[3].color.copy( chassisMaterials[9].color );
					chassisMaterials[3].specular.copy( chassisMaterials[9].specular );

					for ( var i = 0, il = parts.length; i < il; i ++ ) {

						var part = parts[ i ];
						scene.add( part );

						dynamicObjects.push( part );

					}

					vehicleConfigs[ "boxter" ] = {

						"parts"			: parts,
						"scale"			: scale,
						"chassisShape"	: chassisShape,
						"vehiclePhysicsProperties" : vehiclePhysicsProperties,
						"maxForce" : 2250.0,
						"maxBrake" : 60.0,
						"maxSpeed" : 200.0

					};

					physicsGateCallback();

				};

				var dx = 3.7;
				var dy = -0.5;
				var dzBack = 6.4;
				var dzFront = 5.7;
				var suspensionRestLength = 0.2;

				var boxterConfig = {

				"chassisUrl"	: "models/utf8/boxter/boxter_body.js",
				"wheelUrl"		: "models/utf8/boxter/boxter_wheel.js",
				"scale" 		: 5.0,
				"position"		: [ 20.0, 4.0, 0.0 ],
				"chassisOffset"	: [ 0.0, 0.5, 0.0 ],

				"wheels" : [

					{
						"isFrontWheel"	: true,
						"mirrored" 		: false,

						"wheelRadius" 			: 1.6,
						"suspensionRestLength" 	: suspensionRestLength,

						"connectionPoint"	: [ -dx, -dy, dzFront ],
						"wheelDirection"	: [ 0, -1, 0 ],
						"wheelAxle"			: [ -1, 0, 0 ]
					},

					{
						"isFrontWheel"	: true,
						"mirrored" 		: true,

						"wheelRadius" 			: 1.6,
						"suspensionRestLength" 	: suspensionRestLength,

						"connectionPoint"	: [ dx, -dy, dzFront ],
						"wheelDirection"	: [ 0, -1, 0 ],
						"wheelAxle"			: [ -1, 0, 0 ]
					},

					{
						"isFrontWheel"	: false,
						"mirrored" 		: false,

						"wheelRadius" 			: 1.6,
						"suspensionRestLength" 	: suspensionRestLength,

						"connectionPoint"	: [ -dx, -dy, -dzBack ],
						"wheelDirection"	: [ 0, -1, 0 ],
						"wheelAxle"			: [ -1, 0, 0 ]

					},

					{
						"mirrored"		: true,
						"isFrontWheel"	: false,

						"wheelRadius"			: 1.6,
						"suspensionRestLength" 	: suspensionRestLength,

						"connectionPoint"	: [ dx, -dy, -dzBack ],
						"wheelDirection"	: [ 0, -1, 0 ],
						"wheelAxle"			: [ -1, 0, 0 ]
					}

				],

				"chassisShape" : {

					"id"	: 1,
					"type"	: "compound",

					"children" : [

						{
							"type" 	: "box",
							"sx"	: 4.193,
							"sy"	: 1.8,
							"sz"	: 10.696,
							"position" : [ 0.0, 1.7, 0.0 ]

						},

						{
							"type" 	: "box",
							"sx"	: 3.763,
							"sy"	: 0.8,
							"sz"	: 3.5,
							"position" : [ 0.0, 1.8 + 1.7 + 0.8, -0.1 ]

						}

					]

				},

				"chassisPhysicsProperties" : {

					"shapeId"	: 1,
					"mass" 		: 750.0,
					"linearSleepThreshold"  : 0.2,
					"angularSleepThreshold" : 0.25

				},

				"vehiclePhysicsProperties" : {

					"chassisId" : 1,

					"maxSuspensionTravelCm" : 750.0,
					"maxSuspensionForce" 	: 6000.0,
					"suspensionStiffness"	: 10.0,
					"suspensionCompression" : 0.83,
					"suspensionDamping"		: 0.88,
					"rollInfluence"			: 0.18

				},

				"debugPhysicsShapes" : false,

				"callback" : boxterCallback

				};

				simulation.loadPhysicsVehicle( boxterConfig );

			}

			function addTerrain() {

				var url = "models/ctm/atomic/atomic_crn.js";
				//var url = "models/bsp/atomic/ctm/atomic_crn.js";

				var callbackGeometriesLoaded = function ( geometries, materials ) {

					materials[227].alphaTest = 0.5;
					materials[232].alphaTest = 0.5;
					materials[249].alphaTest = 0.5;

					materials[232].side = XG.DoubleSide;


					// windows

					materials[222].transparent = true;
					materials[222].shininess = 1024;
					materials[222].bumpScale = 0.1;

					// road

					materials[ 46 ].shininess = 0.00125;

					var glossMap = XG.ImageUtils.loadTexture( "models/ctm/atomic/atomic_material_206_shininess.jpg" );
					glossMap.wrapS = glossMap.wrapT = XG.RepeatWrapping;

					materials[ 46 ].glossMap = glossMap;

					// hills

					var hillShininess = 1;
					var hillBump = 0.9;

					materials[ 40 ].shininess = hillShininess;
					materials[ 41 ].shininess = hillShininess;
					materials[ 47 ].shininess = hillShininess;
					materials[ 76 ].shininess = hillShininess;
					materials[ 77 ].shininess = hillShininess;
					materials[ 79 ].shininess = hillShininess;
					materials[ 81 ].shininess = hillShininess;
					materials[ 250 ].shininess = hillShininess;
					materials[ 251 ].shininess = hillShininess;
					materials[ 252 ].shininess = hillShininess;
					materials[ 253 ].shininess = hillShininess;
					materials[ 254 ].shininess = hillShininess;

					materials[ 40 ].bumpScale = hillBump;
					materials[ 41 ].bumpScale = hillBump;
					materials[ 47 ].bumpScale = hillBump;
					materials[ 76 ].bumpScale = hillBump;
					materials[ 77 ].bumpScale = hillBump;
					materials[ 79 ].bumpScale = hillBump;
					materials[ 81 ].bumpScale = hillBump;
					materials[ 250 ].bumpScale = hillBump;
					materials[ 251 ].bumpScale = hillBump;
					materials[ 252 ].bumpScale = hillBump;
					materials[ 253 ].bumpScale = hillBump;
					materials[ 254 ].bumpScale = hillBump;

					// houses

					materials[ 255 ].side = XG.DoubleSide;
					materials[ 256 ].side = XG.DoubleSide;
					materials[ 257 ].side = XG.DoubleSide;

					// trees

					materials[ 258 ].alphaTest = 0.5;
					materials[ 258 ].side = XG.DoubleSide;
					materials[ 258 ].shininess = 1;

					materials[ 280 ].alphaTest = 0.5;
					materials[ 280 ].side = XG.DoubleSide;
					materials[ 280 ].shininess = 1;

					materials[ 338 ].alphaTest = 0.5;
					materials[ 338 ].side = XG.DoubleSide;
					materials[ 338 ].shininess = 1;

					materials[ 339 ].alphaTest = 0.5;
					materials[ 339 ].side = XG.DoubleSide;
					materials[ 339 ].shininess = 1;

					// towers

					materials[ 261 ].shininess = 1;
					materials[ 264 ].shininess = 1;

					// town gate

					materials[ 320 ].alphaTest = 0.5;
					materials[ 320 ].side = XG.DoubleSide;

					// town tree

					materials[ 325 ].alphaTest = 0.5;
					materials[ 325 ].side = XG.DoubleSide;

					//materials[ 257 ].color.setHSV( 0, 1, 1 );

					for ( var i = 0, il = geometries.length; i < il; i ++ ) {

						var geometry = geometries[i];
						geometry.dynamic = true;

						var mesh = new XG.Mesh( geometry, materials[ i ] );

						var s = LEVEL_SCALE;
						mesh.scale.set( s, s, s );
						mesh.position.y = 12779.2626953125 * s - 55;
						mesh.position.x = 150;
						mesh.position.z = 400;

						mesh.castShadow = true;
						mesh.receiveShadow = true;

						scene.add( mesh );

						levelGeometries.push( [ geometry, mesh ] );

						geometry.computeBoundingBox();
						var dimensions = new XG.Vector3();
						dimensions.sub( geometry.boundingBox.max, geometry.boundingBox.min );
						//console.log( "boundingBox", Math.max( dimensions.x, Math.max( dimensions.y, dimensions.z ) ) );

						// recenter pieces

						if ( 1 ) {

							var boundingBox = geometry.boundingBox;

							var center = boundingBox.min.clone();
							center.addSelf( boundingBox.max );
							center.multiplyScalar( -0.5 );

							var translate = new XG.Matrix4();
							translate.makeTranslation( center );

							geometry.applyMatrix( translate );
							geometry.computeBoundingSphere();

							center.multiplyScalar( s );
							mesh.position.subSelf( center );

						}

					}

					physicsGateCallback();

					ambientLight.visible = false;
					lightProbesManager.update();
					ambientLight.true = false;

				};

				var callbackAllLoaded = function () {

					checkStatus();

					ambientLight.visible = false;
					lightProbesManager.refreshProbes();
					ambientLight.visible = true;

					progressBarElement.style.display = "none";

				};

				// progress tracking

				var filesInProgress = {};
				var allTotal = 0;
				var allLoaded = 0;

				var callbackProgress = function ( message ) {

					var url = message.url;
					var total = message.total;
					var loaded = message.loaded;

					if ( filesInProgress[ url ] === undefined ) {

						filesInProgress[ url ] = {

							"total" : 0,
							"loaded": 0

						};

					}

					filesInProgress[ url ].loaded = loaded;
					filesInProgress[ url ].total = total;

					allLoaded = 0;
					allTotal = 0;

					for ( var f in filesInProgress ) {

						var file = filesInProgress[ f ];

						allLoaded += file.loaded;
						allTotal += file.total;

						//console.log( "file", f, "loaded", file.loaded, "total", file.total );

					}

					allTotal = Math.min( allTotal, 21281112 );

					progressLoadedElement.style.width = Math.round( ( allLoaded / allTotal ) * 700 ) + "px";

					//console.log( "loaded", allLoaded, "total", allTotal );

				};


				var parameters = {

					"callbackGeometriesLoaded" 	: callbackGeometriesLoaded,
					"callbackProgress"			: callbackProgress

				};

				var loader = new XG.CTMLoader();
				loader.loadParts( url, callbackAllLoaded, parameters );

			}

			function initObjects() {

				addTerrain();

				numVehicles = 3;

				addZilPhysics();
				addWranglerPhysics();
				addBoxterPhysics();

			}

			function setCurrentCar( index ) {

				var vehicle = vehicleConfigsList[ index ];
				currentVehicle = vehicle;

				var modelScale = vehicle[ "scale" ];
				var chassis = vehicle[ "parts" ][ 0 ];

				gyro.add( camera );
				gyro.scale.set( 1, 1, 1 ).multiplyScalar( 1.0 / modelScale );
				chassis.add( gyro );

			}

			function resetCar( index ) {

				var vehicle = vehicleConfigsList[ index ];

				var chassis = vehicle[ "parts" ][ 0 ];

				// reset flipping over

				chassis.quaternion.set( 0, 0, 0, 1 );

				// reset falling down

				if ( chassis.position.x < -FLOOR_SIZE * 0.5 || chassis.position.x > FLOOR_SIZE * 0.5 ||
					 chassis.position.z < -FLOOR_SIZE * 0.5 || chassis.position.z > FLOOR_SIZE * 0.5 ||
					 chassis.position.y < -10 ) {

					chassis.position.set( 20 * index, 1,  0 );

				}

				simulation.resetTransforms();

			}

			function toggleLighting() {

				lightingIndex = ( lightingIndex + 1 ) % lightingList.length;

				var lighting = lightingList[ lightingIndex ];
				var position = lighting.position;
				var color = lighting.color;

				var oldX = dayLight.position.x;
				var oldY = dayLight.position.y;
				var oldZ = dayLight.position.z;

				var newX = position[ 0 ] * 10;
				var newY = position[ 1 ] * 10;
				var newZ = position[ 2 ] * 10;

				var oldHSV = dayLight.color.getHSV();

				var oldH = oldHSV.h;
				var oldS = oldHSV.s;
				var oldV = oldHSV.v;

				var newH = color[ 0 ];
				var newS = color[ 1 ];
				var newV = color[ 2 ];

				var tweenFrom = { x: oldX, y: oldY, z: oldZ,
								  h: oldH, s: oldS, v: oldV,
								  intensity: dayLight.intensity,
								  ambientIntensity: dayLight.ambientIntensity,
								  skyBrightness: skyUniforms.skyBrightness.value };
				var tweenTo   = { x: newX, y: newY, z: newZ,
								  h: newH, s: newS, v: newV,
								  intensity: lighting.sunIntensity,
								  ambientIntensity: lighting.ambientIntensity,
								  skyBrightness: lighting.skyBrightness };
				var duration = 1500;

				var callbackUpdate = function () {

					dayLight.position.set( this.x, this.y, this.z );
					dayLight.color.setHSV( this.h, this.s, this.v );

					//dayLight.intensity = this.intensity;
					//dayLight.ambientIntensity = this.ambientIntensity;

					skyUniforms.skyBrightness.value = this.skyBrightness;

				};

				var callbackComplete = function () {

					ambientLight.visible = false;
					lightProbesManager.refreshProbes();
					ambientLight.visible = true;

				};

				var tween = new TWEEN.Tween( tweenFrom ).to( tweenTo, duration ).easing( TWEEN.Easing.Sinusoidal.InOut )
								.onUpdate( callbackUpdate ).onComplete( callbackComplete ).start();

			}

			function toggleDOF() {

				renderer.setDOF( ! renderer.dofEnabled );

			}

			function toggleCamera() {

				cameraIndex = ( cameraIndex + 1 ) % cameraList.length;

				var cameraSettings = cameraList[ cameraIndex ];
				var fov = cameraSettings.fov;
				var dofFocusWidth = cameraSettings.dofFocusWidth;
				var dofFocusRampWidth = cameraSettings.dofFocusRampWidth;

				var callbackUpdate = function () {

					camera.fov = this.fov;
					camera.updateProjectionMatrix();

					renderer.dofFocusWidth = this.dofFocusWidth;
					renderer.dofFocusRampWidth = this.dofFocusRampWidth;

					var fovRad = XG.Math.degToRad( camera.fov );
					renderer.dofLensFocalLength = XG.Math.fovToFocalLength( fovRad, 24 );

				}

				var tweenFrom = { "fov": camera.fov, "dofFocusWidth": renderer.dofFocusWidth, "dofFocusRampWidth": renderer.dofFocusRampWidth };
				var tweenTo = { "fov": fov, "dofFocusWidth": dofFocusWidth, "dofFocusRampWidth": dofFocusRampWidth };
				var duration = 1000;

				var tween = new TWEEN.Tween( tweenFrom ).to( tweenTo, duration ).easing( TWEEN.Easing.Sinusoidal.InOut )
								.onUpdate( callbackUpdate ).start();

			}


			// -----------------------------

			function onWindowResize ( event ) {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				WIDTH = window.innerWidth;
				HEIGHT = window.innerHeight - 2 * MARGIN;

				renderer.setSize( WIDTH, HEIGHT );

				camera.fov = FOV;
				camera.aspect = WIDTH / HEIGHT;
				camera.updateProjectionMatrix();

			}

			function onDocumentMouseMove ( event ) {

				mouseX = ( event.clientX - windowHalfX ) * 1;
				mouseY = ( event.clientY - windowHalfY ) * 1;

			}

			function onKeyDown ( event ) {

				switch( event.keyCode ) {

					case 38: /*up*/
					case 87: /*W*/ 	characterControls.moveForward = true; break;

					case 40: /*down*/
					case 83: /*S*/ 	 characterControls.moveBackward = true; break;

					case 37: /*left*/
					case 65: /*A*/   characterControls.moveLeft = true; break;

					case 39: /*right*/
					case 68: /*D*/    characterControls.moveRight = true; break;

					case 32: /*space*/ characterControls.brake = true; break;

					case 49: /*1*/	setCurrentCar( 0 ); break;
					case 50: /*2*/	setCurrentCar( 1 ); break;
					case 51: /*3*/	setCurrentCar( 2 ); break;
					case 52: /*4*/	setCurrentCar( 3 ); break;

					case 66: /*B*/	resetCar( 0 ); break;
					case 78: /*N*/	resetCar( 1 ); break;
					case 77: /*M*/	resetCar( 2 ); break;

					case 76: /*L*/	toggleLighting(); break;
					case 80: /*P*/	toggleDOF(); break;
					case 79: /*O*/	toggleCamera(); break;

				}

			};

			function onKeyUp ( event ) {

				switch( event.keyCode ) {

					case 38: /*up*/
					case 87: /*W*/ characterControls.moveForward = false; break;

					case 40: /*down*/
					case 83: /*S*/ 	 characterControls.moveBackward = false; break;

					case 37: /*left*/
					case 65: /*A*/ 	 characterControls.moveLeft = false; break;

					case 39: /*right*/
					case 68: /*D*/ 	  characterControls.moveRight = false; break;

					case 32: /*space*/ characterControls.brake = false; break;

				}

			};

			// -----------------------------

			function animate() {

				requestAnimationFrame( animate );

				render();

				stats.update();
				showPhysicsFPS();

			}

			function render() {

				var time = Date.now();
				var delta = clock.getDelta();

				//

				TWEEN.update();

				//

				if ( loaded ) {

					ambientLight.visible = false;
					lightProbesManager.update();
					ambientLight.visible = true;

				}

				// update camera

				targetX = mouseX * .002;
				targetY = mouseY * .002;

				angle  += 0.05 * ( targetX - angle );
				height += 0.05 * ( targetY - height );

				var cameraDistance = 65;

				var x = -Math.sin( angle * 2 ) * cameraDistance;
				var z =  Math.cos( angle * 2 ) * cameraDistance;
				var y = 50 * height + 50;

				camera.position.set( x, y, z );
				camera.lookAt( target );

				// update vehicle

				if ( currentVehicle ) {

					var vehicleId = currentVehicle[ "vehicleId" ];

					var maxForce = currentVehicle[ "maxForce" ];
					var maxBrake = currentVehicle[ "maxBrake" ];

					var currentSpeed = currentVehicle[ "vehiclePhysicsProperties" ][ "speed" ];
					var maxSpeed = currentVehicle[ "maxSpeed" ];

					//console.log( currentSpeed );

					var steerSpeed = 1.0;
					var steerSpeedDecay = 1.0;
					var maxWheelSteering = Math.PI * 0.2;

					if ( characterControls.moveLeft ) {

						vehicleSteering += delta * steerSpeed;

					} else if ( characterControls.moveRight ) {

						vehicleSteering += -delta * steerSpeed;

					} else {

						if ( vehicleSteering > 0 ) {

							vehicleSteering = XG.Math.clamp( vehicleSteering - delta * steerSpeedDecay, 0.0, maxWheelSteering );

						} else if ( vehicleSteering < 0 ) {

							vehicleSteering = XG.Math.clamp( vehicleSteering + delta * steerSpeedDecay, -maxWheelSteering, 0.0 );

						}

					}

					vehicleSteering = XG.Math.clamp( vehicleSteering, -maxWheelSteering, maxWheelSteering );

					if ( characterControls.moveForward ) {

						vehicleForce = maxForce;

						if ( currentSpeed >= maxSpeed ) vehicleForce = 0.0;

					} else if ( characterControls.moveBackward ) {

						vehicleForce = - maxForce;

						if ( currentSpeed <= -maxSpeed * 0.5 ) vehicleForce = 0.0;

					} else {

						vehicleForce = 0.0;

					}

					if ( characterControls.brake ) {

						vehicleBrake = maxBrake;

					} else {

						vehicleBrake = 0.0;

					}

					if ( simulation ) {

						simulation.applyEngineForce( vehicleForce, vehicleId );
						simulation.setSteering( vehicleSteering, vehicleId, 0 );
						simulation.setSteering( vehicleSteering, vehicleId, 1 );
						simulation.setBrake( vehicleBrake, vehicleId );

					}

				}

				// render

				renderer.render( scene, camera );

			}

		</script>
	</body>

</html>
